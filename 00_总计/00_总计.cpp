// 00_总计.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"


int main()
{
    return 0;
}

//  [6/16/2017 YXP]
// ---------------------------------The More Effictive CPlusPlus-----------------

//3.1 M1:指针和引用的区别:
// 1.引用必须被初始化并且不能指向空值，因此当需要使用一个变量指向一个对象时，
// 如果该变量的值可以改变那么应该申明为指针，否则应该为引用
// 2.不存在空值的问题使得引用的效率更高，使用指针前总应该if(p==null){...}来测试其合法性
// 3.指针可以指向不同的对象，引用不能，只能初始化的时候指定,之后不能改变。
// 4.重载操作符的时候防止出现语义错误，应该使用引用，比如重载[]操作符，返回值就应该是引用，指针的话还得*()一下
// 所以总的来说: (1)存在可能指向不同对象或者不指向任何对象的情况，用指针。
//				(2)总是指向一个对象并且不会改变指向，用引用。
//				(3)操作符重载的时候防止语义无解，使用引用。



//3.2 M2:（EffectiveC++ M27）
// 1.因为传统C风格的不对去掉const和改变对象类型(父类指针转换为子类指针)进行区分
// 2.并且不利于人工阅读，主要是grep等工具不好处理
// 3.static_cast和C风格类型转换一样，除了不能去掉const和从基本类型与引用类型相互转换(比如int转换成一个Widget)
// 4.const_cast用于去掉const,(不能增加const属性)，增加直接用static_cast
// 5.dynamic_cast用于安全的沿着类的继承关系向下进行类型转换，
// 即把基类的指针或引用转换成指向其派生类或兄弟类的指针或引用
// 转换失败会返回空指针或者报异常,且必须子类和父类之间有多态性(虚函数)才能转型
// 6.reinterpret_cast用于函数指针之间的转换，但是基本建议少用(实际上reinterpret_cast才是最接近C转型的，无所不能。)
// 参见Test_Cpps 41 和02_01

//3.3 M3:不要对数组使用多态
// 1.如果对数组使用多态，其地址(由指针计算)还是基类的大小，因此各种操作都可能出错
// 编译器假设数组中元素和基类对象大小一致
// 在删除对象的时候也是，会假设是基类对象来delete.
// 
// 2.尽量不要从一个具体类派生出另一个具体类能够尽可能避免这个问题

//3.4 M4:避免无用的缺省构造函数
// 1.缺省构造函数通常无法正确使对象的每一个数据成员都有意义
// 2.但没有了缺省构造函数会无法直接建立数组(堆和非堆)，不能Widget w[10]; //没有默认构造函数
// 3.解决方法有(参见04_01):
//			   (1)非堆数组的话，直接initializer list里面指定每一项，比如Widget w[]={Widget(10),Widget(20)};
//			   (2)用指针数组来解决，但是必须记得delete并且会多出来存储空间的使用并且增加了内存使用量。(还很麻烦)
//             (3)使用placement new分配raw memory，但是必须手动调用需要的析构函数，而不能直接delete
// 4.没有缺省构造函数还会使得一些模板类没法用，因为这些模板类里面一般都有T data[xxx]的用法。
// 但是基本上都可以用上面的方法去解决，比如std::vector就不依赖于默认构造函数(亲测发现VC和mingw都需要)。
// 5.所以当你不能确定使用缺省构造函数的时候这个类也能被高效率和正确的创建，那么就不要使用缺省构造函数


//4.1 M5:谨慎定义类型转换函数
// 1.隐式类型转换函数的声明和定义参见05_01
// 2.proxy ckasses解决方法,参见05_02
// 3.proxy对象 能够帮助控制在软件的某些方面的行为。

//4.2 M6:前置和后置版本的++
// 1.后置版本效率更低，因为要创建临时对象，但是返回的对象是const的，所以禁止使用i++++,但是可以++++i;
// 2.自己的类的increment和decrement应该都根据其前缀形式来实现，便于维护并且效率更好。
// 实现参见06_01

//4.3 M7:不要自己重载&&或者||,','
// 1.C++对布尔表达式采取短路求值法，所以自己重载后，调用函数的时候，两个表达式都是注定要被计算的，
// 便不能实现高效的判断了
// 2.对于逗号运算符，其是先运算最左边的再依次往右，但是自行重载的却不能确保能够有这样的效果。
// 3.不能重载的运算符:.	.*	::	?:
//					new	delete	sizeof	typeof
//					static_cast等四个转换函数


//4.4 M8:operator new 和 new operator
// 1.new 一个对象的时候，调用的是new operator,这个是系统的操作符，不能修改
// 2.new Widget()的内部会调用operator new,再调用构造函数，所以
// operator new的作用就类似于malloc，负责分配内存，但是完全和构造函数无关
// 3.placement new的作用是对于已经分配好的raw内存，显式调用构造函数构造对象再返回其指针
// 语法: new (p)ClassName(params...)
// 4.如果想要定制堆对象创建的内存分配过程，可以重写operator new
// 5.对应的还有operator new[]。
// 参考08_01和test_cpps_54_01_02

//5.1 M9:使用析构函数防止资源泄露
// 1.资源应该被封装在一个对象里面(比如unique_ptr)，这样，
// 即使报异常的情况下，也不会出现资源泄露
// 因为构造完成的对象，都会经过析构函数
// 如果用try catch来catch后使用delete,那么代码需要使用两份，因此也不好，
// 最好的办法还是使用对象来管理资源(auto_ptr)。
// 2.如果是对象数组的话，那么可以使用vector

//5.2 M10:在构造函数中防止资源泄露
// 1.如果构造函数过程中报了异常(有一部分内存已经分配，另一部分还没分配)，这时new出来的指针是空值，是无法通过delete删掉的
// 而且对象本身此时也构造失败，不会调用其析构函数。
// 2.解决:面对组合型对象的时候，用unique_ptr代替传统指针，只要任何一部分构造成功了，那么unique_ptr都会调用其析构函数进行delete
// 详细实现参考10_01

//5.3 M11:禁止异常传递到析构函数之外
// 1.析构函数会在两种情况下被调用，一是正常删除一个对象的时候，比如超出作用域或者被delete,另外一种是异常传递的《堆栈辗转开解stack-unwinding》过程中，由异常处理系统来删除一个对象。
// 2.析构函数内部是没有办法区分这两种情况的，如果在一个异常被激活的同时，析构函数也抛出异常，程序控制权转移到了析构函数外面，C++将调用terminate函数终止程序。
// 3.在异常转递的过程中，防止terminate被调用(没看懂)
// 4.帮助我们确保析构函数能够完成执行
// 具体实现参考11_01

//5.4 M12:抛出异常和传递参数和调用虚函数之间的差异
// 1.造成这些差异的主要原因:调用函数的时候程序控制权还会返回函数调用处，但是抛出异常则不会。
// 2.区别主要三点:
//  (1) 无论通过传值还是传引用，都会拷贝对象，因为如果抛出去的对象是引用的话，那么离开生存空间后，局部对象会析构，那么外部拿到的是尸体了，没用。
//      即使抛出的对象不会被释放也还是会拷贝。这也意味着catch块中不能修改捕获的对象，总是拷贝了副本。
//		异常对象被拷贝的时候，是调用对应静态类型的拷贝构造函数而不是动态类型，因此如果
//		Base &r = DerivedObj;
//		throw r; //之后拿到的拷贝是一个Base对象了。
//		catch(e){throw;} 和 catch(xxException e){throw e;} 的区别就是:第一种方式抛出的时候没有拷贝，如果是r的话那么会保持对象不变(仍然底层是DerivedObj)
//		第二种方式抛出的时候会做拷贝，就一定抛出xxException 类型了，会改变异常的类型可能。
//		并且使用引用抛出的时候，只会拷贝一次，使用值传递拷贝的时候，会被拷贝两次。
//      一个被异常抛出的对象总是一个临时对象，并且可以通过引用捕获却不需要是const reference，这和参数不一样(临时对象不能用普通引用)
//		因此抛出异常的速度比参数传递要慢
//	(2) 异常捕获的时候不支持类型转换，捕获double类型不能传入int类型。只支持两种类型转换:
//		派生类与基类(传值，引用，指针都可以)
//		从类型指针转换到const void *,所以const void *能够捕获任意类型指针异常。
//  (3)	catch块进行捕捉的时候和函数不一样，函数是按照if else规定的来，catch则是最近的最优先，因此如果一开始就捕获基类的，后面子类的就捕获不到了，因此尽量按照继承顺序来。
//		就算这时候你传的引用具有多态性质也是一样，而函数调用的时候回去查找虚函数。

// M13: 通过reference捕获异常
// 1.通过指针抛出理论上效率应该是最高的(这时只拷贝指针，不拷贝对象)，但是必须确保对象还是生存的，基本上都不会保持生存期除了全局和静态。
// 而且调用者还不知道是否应该删除这个对象。
// 2.四个标准异常: bad_alloc,bad_cast(dynamic_caast失败抛出),bad_typeid(当dynamic_cast对空指针操作抛出),bad_exception(unexcepted异常)
// 3.使用值传递会拷贝两次并且有slicing problem.因此就使用引用捕获是最好的。

// M14: 使用异常规格的时候需要小心
// 1.如果一个函数抛出了不在异常规格范围里的异常，那么运行时将会调用unexpected函数
// 就是说int func() throw(exception1) 指明了只能抛出exception1 但是这时却抛出了exception2的异常，就会调用unexpected函数
// 这个函数默认的行为是调用terminate,terminate调用abort，就会终止程序

// M15: 异常处理的系统开销
// 1.为了能够在运行时处理异常，程序要记录大量的信息。try catch throw 每一个关键字都会有开销。
// 2.空间上需要建立数据结构来跟踪对象是否完全构造啊，cpu还要保持这些数据结构更新。
// 3. throw() 异常规格也是有开销的
// 4.因此建议只在明确知道存在异常的情况下才抛出异常。

//M17:考虑使用layzy evaluation
// 1.不需要拷贝的地方就不要拷贝，使用引用
// 2.区别对待读和写，读取reference-counted string是很容易的，写入的话就需要生成副本。
// 3.使用懒惰提取(lazy fetching)，成员使用指针，每次需要了才去实例化，缺点是每次使用都需要判断是否需要实例化。
// 4.懒惰表达式计算,比如需要矩阵的第几个位置才计算。

//M18:over-eager evaluation
// 1.如果你认为一个计算需要频繁进行，就可以设计一个数据结构高效的处理这些计算需求，这样可以降低每次计算需求的开销
//   比如使用caching缓存那些已经被计算出来而后还可能再被使用的值。
// 2.比如vector的实现方式，capacity和size是不一样的，每次分配新空间的时候，
// 总是会提前分配两倍当前大小的容量，以备下次使用,这是以空间换时间的做法


//6.4 M19:临时对象的来源搞清楚
// 1.临时对象出现在(1):返回对象值的时候(2):为了是函数成功调用而进行隐式类型转换的时候
// 2.非常量引用进行隐式类型转换是直接被禁止的，常量引用虽然没被禁止(因此可以成功调用),具体参考19_01
//，但是不应该用，产生了多余的开销。

//6.5 M20:返回值里的临时对象的优化
// 1.通过在return里面运用constructor argument可以产生优化省掉一次copy ctor和dtor，参考20_01,但是copy assignment是没法优化的。
// 2.这个没什么好优化的，只能忍受

//6.6 M21:通过重载避免隐式类型转换
// 1.当可能出现隐式类型转换的时候，可以通过重载来避免
// 比如UInt类只有一个int成员的时候，重载+号运算符就可以避免+号的时候出现类型转换
// const UInt operator+(const UInt& lhs,int rhs);

//6.7 M22:尽量用运算符的赋值形式代替其单独形式
// 1.x = x - y和x-=y的区别在于，前者产生返回值，会生成临时对象，因此效率更低
// 2.自定义类型必须显式实现-=这种赋值运算符，光实现了operator-是不行的，两者无关
// 3.operator(stand-alone形式)建议根据assignment version来实现，
// 并且自己在设计类的时候，一定要两者都提供，用户用的时候才能选择
// 比如Rational a,b,c,d; result=a+b+c+d;虽然效率第一点点，但是可读性更好
// 而result+=a;+=b;+=c;...虽然效率高但是不利于维护，因此要让用户自己选择
// 4.返回值里面需要产生新对象的话，尽量用returl constructor(argument);的形式,
// 非命名对象可能能够享受到编译器的优化。
// 5.作为开发者从效率考虑的话，尽量用assignment version

//6.8 M23:当程序性能遇到瓶颈的时候，考虑更换程序库
// 1.iostream 相比于 stdio而言，效率更低，但是类型安全且可扩展


//七:技巧
//7.1 M25:将构造函数和非成员函数虚拟化
// 1.构造函数本身是不能为virtual的，但是通过类似于工厂类的设计思路，
// 可以产生虚拟构造函数的效果(根据不同的输入，生成不同对象)
// 2.虚拟拷贝构造函数，通常这种函数命名为clone,然后子类实现的时候分别new一个对象，
// 再返回自己的类型指针,这里用到了虚函数返回类型可以不一致，但是必须是可协变的(继承关系的指针之间)
// 3.虚拟非成员函数，先写虚函数，子类各自实现，然后一个非成员函数，
// inline并且需要一个该类型的参数，便可以实现类似于虚函数的多态效果

//7.2 M26:阻止建立类对象的设计方法
// 1.把该类的两个构造函数声明为private
// 2.提供友元函数返回一个static该类的对象
// 3.该类自己提供一个返回static该类对象的成员函数
// 4.上述两种做法的区别在于，函数里的静态对象只有用到的时候才会生成，而类里面的即使不调用也会建立
// 不过代价是每次调用该函数都要检查是否需要建立对象,成员函数版本的缺点还有一个就是不确定什么时候初始化
// 5.但是这种非成员函数版本的不要声明为inline的
// 6.对象计数:若直接用静态成员实现对象计数的三种情形:1.该类本身2.作为其他类的基类3.被嵌入其他类(用于组合)
// 要避免后两种情况，只能直接把构造函数声明为private,就不能用做基类和组合了
// 7.直接通过友元的办法来实现单例模式，缺点是不能自由控制对象的销毁，不能先new 在delete再new这样，
// 解决方法是通过引用计数和伪构造函数的方法相结合
// 8.通过静态成员必须重新定义，可以实现控制各自类计数的办法


//7.3 M27:要求或禁止在堆中建立对象
// 1.要求必须在堆中建立对象:
// (1):构造函数全部public ,但是析构函数private,再提供一个destroy接口，delete this来调用析构函数
// 这种方法还是可以直接构造函数在栈上构建对象，但是在析构的时候会报错。所以也算是控制了只能在堆上创建。
// 参见26_01
// (2):构造函数全部private,然后通过修改new的操作便能控制只在堆上创建
// 第二种方法缺点比较大，因为构造函数往往不止一个，不利于维护
// 并且这种写法的话，组合和继承直接无法编译，因为无法访问西沟函数，解决方法是把析构函数换成protected解决继承，把对象换成指针解决组合
// 2.判断对象是否在堆中:
// (1)可以通过静态成员(bool isOnHeap)配合改写operator new(new的时候令isOnHeap为true)来实现判断，
// 但是会在operator new[] 和多个对象时出问题
// (2)程序的地址空间管理: 栈在上(高地址)，往下延伸，堆在下，网上延伸，因此下面方法是个不错的选择来判断是否在堆上
//	bool OnHeap(const void *addr) 
//	{
//		char onTheStack;
//		return addr < &onTheStack; //新的局部栈对象始终是最小的栈地址，堆对象一定小于栈地址
//	}
// 但是还有一种全局的静态对象的存在，通常是在堆的底端。
// (3)实现一个不污染全局命名空间，没有额外开销，没有正确性问题的基类用于检查是否在堆上。
// 参见27_01:HeapTrack类，缺点是不能用于内置类型，因为内置类型也没有this指针
// 3.禁止对象在堆中产生:
// (1):把operator new声明为private就可以了，全局的new operator会来调用这个函数
// (2):同时也建议把delete声明为private,只是为了对应。
// (3):如果禁止数组的话也可以把operator new[]声明为private



//7.4 M28:灵巧指针
// 1.具体实现参加28_01
// 2.灵巧指针的拷贝和赋值采用对象转移的方式，因此在作为参数的时候，除非特殊需要，一定不能传值，要传const引用
// 3.解引用返回的是引用而不是对象，返回对象的话，多态的时候会出现slicing问题，因此也就不支持虚函数了
// 4.通过模板成员函数，可以实现灵巧指针的父类和子类灵巧指针对象之间的相互转换,
// 其实是所有指针之间可以隐式转换的，都可以转换了
// 5.但是出现间接基类的时候，就可能二义性，比如C:B:A,那么这时候C向B和A转换的优先级是一样的，这也是灵巧指针的缺点，没法解决。
// 6.灵巧指针里SmartPtr<T>和SmartPtr<const T>是两个完全不同类型，因此不可能转换
// 通常的做法是把SmartPtr继承自一个SmartPtrToConst<T>类